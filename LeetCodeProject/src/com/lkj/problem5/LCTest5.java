package com.lkj.problem5;

/** 动态规划
 第 1 步：定义状态：dp[i][j] 表示子串 s[i..j] 是否为回文子串，这里子串 s[i..j] 定义为左闭右闭区间，可以取到 s[i] 和 s[j]

 第 2 步：思考状态转移方程
    dp[i][j] = S[i]=S[j] and dp[i+1][j-1]
 即要判断 S[i,j] 是否是回文子串，那么首先它的首尾字符必须相等，如果首尾字符不相等，必然不是回文子串；其次它的内部子串 S[i+1,j-1]必须也是回文子串。
 此时我们需要考虑临界条件，即S[i+1,j-1]必须存在，那么S[i+1,j-1]最小的时候，他就是一个字符，即 i+1>=j-1，即 j>=i+2.
 当 j=i+1 的时候，即 S[i,j]只有2个字符，只需要判断首尾字符是否相等，既可以判断S[i,j]是不是回文子串
 当 j=i 的时候，S[i,j] 必然是回文子串。

 第 3 步：考虑初始化
 初始化的时候，单个字符一定是回文串，即当 j=i 的时候，S[i,j] 必然是回文子串，因此把对角线先初始化为 true，即 dp[i][i] = true

 第 4 步：考虑输出
 只要一得到 dp[i][j] = true，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，
 记录此时的回文子串的「起始位置」和「回文长度」即可。

 第 5 步：考虑优化空间
 不优化

 注意事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果，即填表顺序很重要。
 也就是说，dp[i+1][j-1] 必须先判断，这样才能判断dp[i][j]。具体分析如下代码

 时间复杂度：O(N^2)
 空间复杂度：O(N^2)
 */
public class LCTest5
{
    public static String longestPalindrome(String s)
    {
        //s的长度为1，只有一个字符，必然是回文子串，最长回文子串就是这个字符。如果s没有字符，也返回s
        if(s.length() <= 1)
            return s;

        //用于判断 从下标j到i 的字符串是不是回文子串，是dp[j][i]就存储true，否则dp[j][i]存储false
        boolean dp[][] = new boolean[s.length()][s.length()];
        //1、首先，当i=j的时候，必然是回文子串，先给所有i=j的初始条件赋值
        for (int i = 0; i < s.length(); i++)
        {
            dp[i][i] = true;
        }

        //这两个值用于记录最长回文子串的范围
        int maxLen = 1;
        int begin = 0;

        //从 i=1 ,j=i-1 开始，我们判断从 下标j 到 下标i 范围内的字符串是不是回文子串。这个过程是从较小的字符串逐渐往较大的字符串判断！
        /**2
         下面，我们从小到大查找所有子串。
         这里，i 被设定为右端，j被设定为左端起点。外循环用于设置右端i的值，让i从1开始；内循环用于使得j=i-1逐渐减少到j=0.具体如下：
         [0,1]  i=1
         [1,2] , [0,2]  i=2
         [2,3] , [1,3] , [0,3]  i=3
         [3,4] , [2,4] , [1,4] , [ 0,4]  i=4
         ....
         我们可以看到，对于每一个 [j,i]，由于j是在不断减小的，那么 [i-1 , j-1]必然已经判断过，这就满足先判断小子串，再判断大子串的原则。
         */
        for (int i = 1; i < s.length(); i++)
        {
            for (int j = i-1; j >= 0 ; j--)
            {
                if(j == i-1)
                    dp[j][i] = (s.charAt(i)==s.charAt(j));//当2个字符相等的时候，2个字符的子串就是回文子串
                else
                    dp[j][i] = dp[j+1][i-1] && (s.charAt(i)==s.charAt(j));//多个字符串的时候，需要左右2个字符相同且 j-1到i-1 的字符是回文字符

                //每次确定一个 dp[j][i]，对最长的字符进行更新
                if(dp[j][i] && i-j+1>maxLen)
                {
                    begin = j;
                    maxLen = i-j+1;
                }

            }
        }
        return s.substring(begin , begin+maxLen);
    }

    public static void main(String[] args)
    {
        System.out.println(longestPalindrome("sdcbaabcfr"));
    }
}

