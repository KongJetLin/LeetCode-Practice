package com.lkj.problem45;

//对比55题：跳跃游戏1
public class LCTest45
{
    /** 思路：贪心+动态规划：贪心，每次都找到这一跳区间内能跳到的最远的距离，作为下一跳的最远的起点，如果到达末尾，直接结束。
     *
    第 0 个位置作为起跳点 1，如果 0 位置的值是 3，从这个 起跳点 起跳叫做第 1 次 跳跃，那么从后面 3 个格子起跳 都 可以叫做第 2 次 跳跃。
     那么我们先遍历第一次起跳的所有起点（只有一个），找到第一次起跳可以跳到的最远距离，从第一次起跳范围的后一个位置开始，到第一次可以跳到的最远距离，
     就是第二次起跳的可能起点，此时第一次跳完后，跳数+1；
     接着，遍历第二次起跳的所有起点，找到第二次起跳可以跳到的最远距离，从第二次起跳范围的后一个位置开始，到第二次可以跳到的最远距离，
     就是第三次起跳的可能起点，此时第二次跳完后，跳数+1；
     ...
     当某一次跳跃的最远距离大于等于 nums.length-1 的时候，说明到达了最后一点，则不需要继续跳跃。
     */
    public int jump(int[] nums)
    {
        //初始化，第一次起跳的起点与终点都是0
        int start = 0;
        int end = 0;
        //初始化跳数
        int jumpNums = 0;
        int longest_jump = 0;//最远可以跳到的距离，初始化为0

        //当end>=nums.length-1的时候，就停止，此时到达终点
        while (end < nums.length-1)
        {
            //遍历某一次起跳的区间
            for (int i = start; i <= end ; i++)
            {
                //遍历这次起跳的区间，更新可以跳到的最远的距离
                //可以跳到的最远的距离肯定大于end，因为题目约定我们最后一定可以跳到终点
                longest_jump = Math.max(longest_jump , i+nums[i]);
            }
            //更新下一次起跳的范围
            start = end+1;
            end = longest_jump;
            //将跳数+1
            jumpNums++;
        }
        return jumpNums;
    }
}
