package com.lkj.problem1071;

/*
当说到最大公因子，想到辗转相乘法：gcd(int a , int b):return b==0 ? a : gcd(b , a%b);
 */
public class LCTest1071
{
    /** 原理说明
    如果S1与S2有最大公因子，那么存在字符串 X（最小单位），使得 S1=n*X，S2=m*X，（注意，X不一定是最大公共子串，最大公共子串可能是X，也看是X的倍数）
     那么，有：
     1）S1+S2=nXmX = S2+S1 = mXnX，即当 S1+S2!=S2+S1 的时候，最大公因子不存在
     2）如果最大公因子存在，我们求得 m与n 的最大公因子（最小为1）为k，n=a1*k , m=a2*k，
     此时有：S1=a1*k*X，S2=a2*k*X，并且k已经是 m,n 的最大公因子，不可能找到比k更大的值，
     满足 ：S1=a1*k*X，S2=a2*k*X，那么S1与S2的最长公共子串长度就是 k，我们取 str1.sub(0,k)即可！

     此外，若最大公因子为1，那么X就是最长公共子段，比如S1长度为7，S2长度为3的时候，此时，只有X满足条件
     */
    public String gcdOfStrings(String str1, String str2)
    {
        //先排除不存在的情况，注意，字符串不能用“==”比较是否相等！，“==”比较的是值！用equals比较是否相等！（不要犯低级的错）
        if(!(str1+str2).equals(str2+str1))
            return "";

        return str1.substring(0 , gcd(str1.length() , str2.length()));
    }

    //迭代法
    private int gcd(int a , int b)
    {
        /*
        （1）若a>b，那么 a%b 小于b，此时将其赋予b，同时将原来b赋予a，则第二次迭代仍然是 a>b，直到找到
        b = a%b = 0，此时a为b的倍数，那么b就是最大公约数。
        （2）若a<=b，那么 a%b = a，此时b=a，而原来的a=b,a与b交换值，接下来的迭代 a>b 见（1）
         */
        while(b != 0)
        {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    private int gcd1(int a , int b)
    {
        /*
        若这次递归的b=0，即上一层递归 a%b=0，即上一层递归 a是b的倍数，上一层递归的b就是最大公约数，即当前的a就是最大公约数。
        如果不是，继续递归查找！
         */
        return b==0 ? a : gcd1(b , a%b);
    }

    /** 辗转相除法原理：
     假设有两个数161和63，我们要求这两个数的最大公因数，不妨假定这个最大公因数为m，我们可以将较大的数161看成63+98，
     63与98的和161可以被m整除，其中63也可以被m整除，自然98可以被m整除；
     所以这个问题就转换为求98和63的最大公因数m（和上面m相等）；
     将98看成63+35，其中63可以被m整除，和98也能被m整除，故35也可以被m整除；
     所以问题进一步转换为求35和63的最大公因数m（和上面m相等）
     ......
     后来转换为求7和7的最大公因数，发现 7%7=0，那么这时7就是161与63的最大公因子
     */
}
